import sys
import copy # lib para a geracao de copias de objetos

import xml.etree.ElementTree as ET
import xmlschema # xmlschema validation

from rich import print
from rich.console import Console

console = Console()

# XMLSchema validation.
# Este trecho de codigo valida o xml.
# Podem ocorrer dois tipos de erro: (1) xml mal-formado e (2) erro de valida√ß√£o.

# checking if flags were used
# if (len(sys.argv)) == 2: # no flags
#   print("\nWARNING!!! No flags were used. Please, see the options below:")
#   print("---------------------------------------------------------------------------------------------------")
#   print("| FLAG\t\t| DEFINITION                                                                      |")
#   print("---------------------------------------------------------------------------------------------------")
#   print('| -c or -C\t| "Compiles" the EvaML script, outputting an XML file to run in the Eva simulator.|')
#   print("| -s or -S\t| Saves/Inserts the JSON file generated by the parser into the robot's database.  |")
#   print("| -r or -R\t| Makes the EVA robot run the script immediately.                                 |")
#   print("---------------------------------------------------------------------------------------------------\n")
#   exit(1) # finish the execution



# Fun√ß√£o de valida√ß√£o do script EvaML. #############################################
def evaml_validator(evaml_file):
  global tree
  try:
    valido = True
    val = schema.iter_errors(evaml_file)
    for idx, validation_error in enumerate(val, start=1):
      print(f'[{idx}] path: {validation_error.path} | reason: {validation_error.reason}')
      valido = False
  except Exception as e:
    print(val)
    print(e)
    return None
  else:
    if valido == True:
      return ET.parse(evaml_file) #
    else:
      return None


###############################################################################
# (Parsing) Processamento do comando (loop)                                              #
###############################################################################
def process_loop(script_node):
    global id_loop_number
    for i in range(len(script_node)):
        if len(script_node[i]) != 0: process_loop(script_node[i])
        if script_node[i].tag == "loop":
            id_loop_number += 1 # var utilizada na cria√ß√£o de nomes de algumas vari√°veis autom√°ticas. Comeca com 1
            loop_copy = copy.deepcopy(script_node[i]) # copia o elemento  <loop>
            c = ET.Element("counter") # cria o <counter> que inicializa a var de itera√ß√£o com o valor zero
            if script_node[i].get("id") != None: # caso o <loop> seja alvo de um goto
                id_loop = script_node[i].attrib["id"] 
                c.attrib["id"] = id_loop
            if script_node[i].get("var") != None: 
                var_loop = script_node[i].attrib["var"] 
                c.attrib["var"] = var_loop
            else: # caso o usuario n√£o defina uma varia√ß√£o para a itera√ß√£o, a variavel default "ITERATION_VAR...." ser√° criada
                # id_loop_number += 1 # var utilizada na cria√ß√£o de nomes de algumas vari√°veis autom√°ticas. Comeca com 1
                var_loop = "ITERATION_VAR" + str(id_loop_number) 
            times_loop = script_node[i].attrib["times"] 
            c.attrib["var"] = var_loop 
            c.attrib["op"] = "=" 
            c.attrib["value"] = "1"  # inicializa a variavel contadora com zero

            script_node.remove(script_node[i]) # remove o elemento <loop> pois n√£o √© mais necess√°rio (temos a sua c√≥pia em )
            script_node.insert(i, c)  # adiciona o <counter> que inicializa a variavel de itera√ß√£o

            s = ET.Element("switch")  # cria o elemento <switch>
            s.attrib["id"] = "LOOP_ID" + str(id_loop_number) + "_" + var_loop  # prefixo padrao do id automatico gerado para o loop _LOOP_ID_
            s.attrib["var"] = var_loop 
            script_node.insert(i + 1, s)  # adiciona o <switch>, com seus filhos, ao elemento script

            cs = ET.Element("case") # cria o elemento <case>
            cs.attrib["op"] = "lte" 
            cs.attrib["value"] = times_loop 

            ####
            ####



            #cs.insert(1, loop_copy)  # aqui, o elemento pai (loop) vem junto, e isso √© ruim pois queremos apenas seus filhos
            cs.extend(loop_copy)  # o extend adiciona apenas os filhos de loop

            c = ET.Element("counter")  # cria o <counter> que incrementa a vari√°vel de itera√ß√£o
            c.attrib["var"] = var_loop
            c.attrib["op"] = "+"
            c.attrib["value"] = "1"
            cs.append(c)

            g = ET.Element("goto")  # cria o <goto> que faz o loop acontecer
            g.attrib["target"] = "LOOP_ID" + str(id_loop_number) + "_" + var_loop  # prefixo padrao do id automatico gerado para o loop _LOOP_ID_

            cs.append(g)  # adiciona o <goto> (que gerar causa a repeti√ß√£o) ao final do <case> 

            # df = ET.Element("default") # cria o elemento <default> para o <case> do loop

            s.insert(0, cs)  # insere o <case> com o corpo dentro do <switch>
            # s.insert(1, df)  # insere o comando <default> que gera a conex√£o com o restante do script, evitando a descontinuidade

            process_loop(script_node) # o processamento de um loop muda a estrutura inicial do scriptnode e precisa ser revisitada



schema = xmlschema.XMLSchema("xml_schema/evaml_schema.xsd")

# Validating the script. #########################################################################
console.clear()
console.rule("\nü§ñ [yellow reverse b]  Parsing the script: " + "file_name" + "  [/] ü§ñ")
print()
script_file = sys.argv[1]
print("[b white reverse] STEP 1. Let's validate de script. [/]\n")
xml_file_ok = evaml_validator(script_file)

if not xml_file_ok:
  print("\n[b white on red blink] VALIDATION ERROR [/]: The script [b white]" + script_file + " [/]failed the validation process with the [b white]XMLSchema[/]. Please, [b white]check[/] the info above. [blink]üëÜ[/]\n")
  exit(1)
else:
  print("   [b green reverse] The script was validated! [/]\n")


# Parsing (Loop processing)
print("[b white reverse] STEP 2. Parsing the file (Expanding <loop> elements). [/]\n")
id_loop_number = 0  # id usado na cria√ß√£o dos ids dos loops
root = xml_file_ok.getroot() # Evaml root node
script_node = root.find("script")
process_loop(script_node)

print("[b white reverse] STEP 3. Generating the EvaML parsed file. [/]\n")
# Gera o arquivo com as macros expandidas (caso existam) para a proxima etapa
xml_file_ok.write("_parsed_file.xml", "UTF-8")



